<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"> <!-- Evita zoom accidental -->
    <title>ECD-Black Friday</title>
    <link rel="icon" type="image/png" href="https://lwfiles.mycourse.app/6508b8ffc3f7433d9a31e6cb-public/7fe4bf92c7b7bde48d3460bcc3cb0b35.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Rajdhani:wght@500;700&family=Teko:wght@300;500;700&display=swap" rel="stylesheet">
    
    <style>
        /* --- ESTILOS GENERALES --- */
        /* MODO OSCURO: Negro profundo para máximo contraste y rendimiento */
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Rajdhani', sans-serif; touch-action: none; /* Vital para móviles */ }

        /* --- ESTILOS DEL LANDING (PORTADA) --- */
        #blocker {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(0, 0, 0, 0), rgba(0, 0, 0, 0)), url('img/portada.jpg');
            background-size: cover; 
            background-position: center;
            background-repeat: no-repeat;
            z-index: 99; display: flex; flex-direction: column; justify-content: center; align-items: center;
            transition: opacity 0.5s;
            overflow: hidden;
        }

        .bg-tape-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            overflow: hidden; z-index: 0; pointer-events: none;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            transform: rotate(-10deg) scale(1.2); 
        }
        .tape-line {
            width: 200%; font-family: 'Teko', sans-serif; font-size: 8vh; font-weight: 700;
            color: rgba(255, 255, 255, 0.05); 
            white-space: nowrap; margin: 1vh 0;
            text-transform: uppercase; letter-spacing: 5px; user-select: none;
        }
        .move-left { animation: scrollTextLeft 60s linear infinite; }
        .move-right { animation: scrollTextRight 60s linear infinite; }
        @keyframes scrollTextLeft { 0% { transform: translateX(0); } 100% { transform: translateX(-25%); } }
        @keyframes scrollTextRight { 0% { transform: translateX(-25%); } 100% { transform: translateX(0); } }

        #top-logos-container {
            position: absolute; top: 40px; width: 100%; max-width: 1400px; 
            display: flex; justify-content: space-between; padding: 0 40px; 
            box-sizing: border-box; z-index: 101;
        }
        .corner-logo {
            width: 18vw; max-width: 280px; min-width: 140px; height: auto;     
            filter: drop-shadow(0 4px 6px rgba(0,0,0,0.5)); transition: transform 0.3s ease;
        }
        .corner-logo:hover { transform: scale(1.05); }

        #main-logo {
            width: 50vw; max-width: 1200px; height: auto; margin-bottom: 10px;
            filter: drop-shadow(0 0 30px rgba(255, 68, 0, 0.6)); 
            animation: float 3s ease-in-out infinite; position: relative; z-index: 102;
        }
        #main-subtitle {
            font-family: 'Teko', sans-serif; font-size: 2rem; color: #fff; text-align: center;
            margin-bottom: 30px; text-shadow: 0 0 15px rgba(255, 255, 255, 0.8), 0 0 30px rgba(255, 255, 255, 0.4);
            letter-spacing: 4px; position: relative; z-index: 102; font-weight: 500;
        }
        @keyframes float { 0% { transform: translateY(0px); } 50% { transform: translateY(-15px); } 100% { transform: translateY(0px); } }

        .instructions {
            border: 1px solid rgba(255, 255, 255, 0.2); padding: 20px 40px; 
            background: rgba(0, 0, 0, 0.85); margin-top: 10px; border-radius: 50px; 
            text-align: center; color: #ccc; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px); font-size: 1rem; letter-spacing: 1px; position: relative; z-index: 102;
        }
        .key { border: 1px solid #ff4400; padding: 2px 8px; border-radius: 4px; font-weight: bold; color: #ff4400; }

        #start-btn {
            margin-top: 50px; padding: 20px 70px; font-size: 3rem; font-family: 'Teko', sans-serif;
            background: #ff4400; border: none; color: #000; cursor: pointer; font-weight: 700; 
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            text-transform: uppercase; letter-spacing: 4px; box-shadow: 0 0 40px rgba(255, 68, 0, 0.4);
            border-radius: 5px; position: relative; z-index: 102;
        }
        #start-btn:hover { 
            background: #fff; color: #ff4400; box-shadow: 0 0 60px rgba(255, 68, 0, 0.8); 
            transform: scale(1.1) rotate(-1deg);
        }

        /* --- UI DEL JUEGO 3D --- */
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 8px; height: 8px;
            background: rgba(0, 0, 0, 0.6); border-radius: 50%; 
            transform: translate(-50%, -50%); pointer-events: none; z-index: 10;
            transition: all 0.2s; border: 1px solid #fff;
        }
        
        #interaction-msg {
            position: absolute; bottom: 15%; width: 100%; text-align: center;
            color: #ff4400; font-size: 1.5rem; font-weight: bold; display: none; 
            text-shadow: 0 0 10px rgba(0,0,0,0.8); font-family: 'Teko'; letter-spacing: 2px;
        }

        /* --- CONTROLES MÓVILES (JOYSTICKS) --- */
        .joystick-zone {
            position: absolute; bottom: 40px; width: 120px; height: 120px;
            background: rgba(255, 255, 255, 0.05); border: 2px solid rgba(255, 68, 0, 0.3);
            border-radius: 50%; pointer-events: auto; z-index: 20; touch-action: none;
            display: none; /* Oculto por defecto en PC */
        }
        #joystick-left { left: 40px; }
        #joystick-right { right: 40px; }
        
        .stick {
            position: absolute; top: 50%; left: 50%; width: 50px; height: 50px;
            background: rgba(255, 68, 0, 0.6); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            box-shadow: 0 0 15px rgba(255, 68, 0, 0.4); border: 1px solid #fff;
        }

        /* Botón de Acción Móvil */
        #mobile-action-btn {
            position: absolute; bottom: 180px; right: 40px; width: 80px; height: 80px;
            background: rgba(255, 68, 0, 0.9); border: 3px solid #fff; border-radius: 50%;
            z-index: 21; display: none; justify-content: center; align-items: center;
            font-family: 'Teko'; font-size: 1.2rem; font-weight: bold; color: #fff;
            box-shadow: 0 0 20px rgba(255, 68, 0, 0.6); cursor: pointer;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }

        /* --- MODAL DE INFORMACIÓN --- */
        #stand-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100; justify-content: center; align-items: center;
            backdrop-filter: blur(8px);
        }
        
        .modal-card {
            width: 85%; max-width: 1200px; height: 70vh; 
            background: #111; border: 1px solid #333; display: flex; 
            box-shadow: 0 0 80px rgba(255, 68, 0, 0.15);
            position: relative; overflow: hidden; 
        }

        /* Ajuste modal para móvil */
        @media (max-width: 768px) {
            .modal-card { flex-direction: column; height: 90vh; width: 95%; }
            .vid-container { height: 40%; margin: 0; width: 100%; border: none; border-bottom: 1px solid #333; }
            .info-container { height: 60%; padding: 20px; margin: 0; border-left: none; text-align: center; overflow-y: auto; }
            .info-container h2 { font-size: 2.5rem; }
            .marquee { display: none; }
            #start-btn { font-size: 2rem; padding: 15px 40px; }
            #main-logo { width: 80vw; }
            .corner-logo { width: 25vw; }
            .instructions { display: none; }
        }

        /* Cintas animadas del modal */
        .marquee {
            position: absolute; background: #000000; color: #ff4400;
            font-family: 'Teko', sans-serif; font-weight: bold; font-size: 1.2rem;
            text-transform: uppercase; letter-spacing: 2px; display: flex;
            align-items: center; overflow: hidden; z-index: 10; user-select: none;
            border-bottom: 1px solid #333;
        }
        .marquee span { white-space: nowrap; padding: 0 20px; }
        .marquee.top { top: 0; left: 0; width: 100%; height: 30px; }
        .marquee.top span { animation: scrollLeft 10s linear infinite; }
        .marquee.bottom { bottom: 0; left: 0; width: 100%; height: 30px; border-top: 1px solid #333; border-bottom: none; }
        .marquee.bottom span { animation: scrollRight 10s linear infinite; }
        .marquee.left { top: 0; left: 0; width: 30px; height: 100%; flex-direction: column; justify-content: center; border-right: 1px solid #333; border-bottom: none;}
        .marquee.left span { writing-mode: vertical-rl; transform: rotate(180deg); animation: scrollDown 10s linear infinite; padding: 20px 0; }
        .marquee.right { top: 0; right: 0; width: 30px; height: 100%; flex-direction: column; justify-content: center; border-left: 1px solid #333; border-bottom: none;}
        .marquee.right span { writing-mode: vertical-rl; transform: rotate(180deg); animation: scrollUp 10s linear infinite; padding: 20px 0; }

        @keyframes scrollLeft { from { transform: translateX(0); } to { transform: translateX(-100%); } }
        @keyframes scrollRight { from { transform: translateX(-100%); } to { transform: translateX(0); } }
        @keyframes scrollDown { from { transform: translateY(-100%); } to { transform: translateY(0); } }
        @keyframes scrollUp { from { transform: translateY(0); } to { transform: translateY(-100%); } }

        .vid-container { 
            flex: 2; background: #000; position: relative; display:flex; align-items:center; justify-content:center; 
            margin: 30px 0 30px 30px; border: 1px solid #333;
        }
        .vid-container iframe { width: 100%; height: 100%; border: none; }
        
        .info-container { 
            flex: 1; padding: 40px; color: #ddd; position: relative; display: flex; 
            flex-direction: column; justify-content: center; border-left: 1px solid #333; 
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%); margin: 30px 30px 30px 0; 
        }
        .info-container h2 { color: #ff4400; font-family: 'Teko'; font-size: 4rem; margin: 0 0 30px 0; line-height: 0.9; text-transform: uppercase; text-shadow: 0 0 20px rgba(255, 68, 0, 0.3);} 
        
        .close-btn { position: absolute; top: 0px; right: 10px; font-size: 3rem; color: #555; background: none; border: none; cursor: pointer; transition: 0.3s; z-index: 20; }
        .close-btn:hover { color: #ff4400; }
        
        .btn-link { 
            display: block; padding: 20px; text-align: center; font-weight: bold; text-decoration: none; 
            margin-top: 20px; font-family: 'Teko'; font-size: 1.8rem; transition: 0.3s; letter-spacing: 1px;
            border-radius: 4px; text-transform: uppercase;
        }
        .btn-buy { background: #ff4400; color: #fff; border: none; } 
        .btn-buy:hover { background: #fff; color: #ff4400; box-shadow: 0 0 30px rgba(255, 68, 0, 0.6); }
        .btn-doc { border: 1px solid #555; color: #aaa; background: transparent; }
        .btn-doc:hover { border-color: #ff4400; color: #ff4400; }
    </style>
</head>
<body>

    <!-- SECCIÓN LANDING -->
    <div id="blocker">
        <div class="bg-tape-container">
            <div class="tape-line move-left">HASTA EL 60% DE DESCUENTO &nbsp;&nbsp; HASTA EL 60% DE DESCUENTO &nbsp;&nbsp; HASTA EL 60% DE DESCUENTO</div>
            <div class="tape-line move-right">HASTA EL 60% DE DESCUENTO &nbsp;&nbsp; HASTA EL 60% DE DESCUENTO &nbsp;&nbsp; HASTA EL 60% DE DESCUENTO</div>
            <div class="tape-line move-left">HASTA EL 60% DE DESCUENTO &nbsp;&nbsp; HASTA EL 60% DE DESCUENTO &nbsp;&nbsp; HASTA EL 60% DE DESCUENTO</div>
            <div class="tape-line move-right">HASTA EL 60% DE DESCUENTO &nbsp;&nbsp; HASTA EL 60% DE DESCUENTO &nbsp;&nbsp; HASTA EL 60% DE DESCUENTO</div>
            <div class="tape-line move-left">HASTA EL 60% DE DESCUENTO &nbsp;&nbsp; HASTA EL 60% DE DESCUENTO &nbsp;&nbsp; HASTA EL 60% DE DESCUENTO</div>
        </div>

        <div id="top-logos-container">
            <img id="logo-left" class="corner-logo" src="img/Logo01.png" alt="Logo Izquierda">
            <img id="logo-right" class="corner-logo" src="img/Logo02.png" alt="Logo Derecha">
        </div>

        <img id="main-logo" src="img/texto_black.png" alt="LLEGÓ EL BLACK FRIDAY">
        <h3 id="main-subtitle">PROGRAMAS, CURSOS Y MEMBRESÍA</h3>

        <div class="instructions">
            <p><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> MOVERSE &nbsp;|&nbsp; MOUSE - MIRAR &nbsp;|&nbsp; CLIC - ABRIR</p>
        </div>

        <button id="start-btn">¿ESTÁS LISTO?</button>
    </div>

    <!-- ELEMENTOS DEL JUEGO 3D -->
    <div id="crosshair"></div>
    <div id="interaction-msg">CLIC PARA ABRIR</div>

    <!-- CONTROLES MÓVILES -->
    <div id="joystick-left" class="joystick-zone">
        <div class="stick"></div>
    </div>
    <div id="joystick-right" class="joystick-zone">
        <div class="stick"></div>
    </div>
    <div id="mobile-action-btn">ABRIR</div>

    <!-- MODAL DE INFORMACIÓN -->
    <div id="stand-modal">
        <div class="modal-card">
            <div class="marquee top">
                <span>ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; </span>
                <span>ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; </span>
            </div>
            <div class="marquee bottom">
                <span>ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; </span>
                <span>ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; </span>
            </div>
            <div class="marquee left">
                <span>ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; </span>
                <span>ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; </span>
            </div>
            <div class="marquee right">
                <span>ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; </span>
                <span>ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; ECD BLACK FRIDAY &nbsp;•&nbsp; </span>
            </div>

            <div class="vid-container" id="video-wrapper"></div>
            <div class="info-container">
                <button class="close-btn" onclick="closeModal()">×</button>
                <h2 id="m-title">TITULO</h2>
                <a id="m-buy" href="#" class="btn-link btn-buy" target="_blank">ACCEDER A LA OFERTA</a>
                <a id="m-doc" href="#" class="btn-link btn-doc" target="_blank">VER BROCHURE</a>
            </div>
        </div>
    </div>

    <script>
        const IFRAME_TEMPLATE = (url) => `<iframe width="100%" height="100%" src="${url}" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>`;
        
        const DATA = [
            { t: "BLACK FRIDAY", pos: "left-back", type: 1, img: 'img/stand1.jpg', vid: "https://www.youtube.com/embed/QYIhIN6BmaY", offer: "https://wa.link/f86xlv", pdf: "https://www.escuelaconstrucciondigital.com/blackfriday" },
            { t: "DIRECCIÓN DE PROYECTOS DE CONSTRUCCIÓN", pos: "left-back", type: 2, img: 'img/stand2.jpg', vid: "https://www.youtube.com/embed/iGDq7k4PVac", offer: "https://wa.link/ayzc8v", pdf: "https://www.escuelaconstrucciondigital.com/bundle/re-direccion-de-proyectos-de-construccion" },
            { t: "CONSTRUCTION PROJECT MANAGER", pos: "left-back", type: 3, img: 'img/stand3.jpg', vid: "https://www.youtube.com/embed/orbIjWjzmu8", offer: "https://wa.link/5vlrsn", pdf: "" },
            { t: "MODELADO Y COORDINACIÓN BIM", pos: "left-front", type: 4, img: 'img/stand4.jpg', vid: "https://www.youtube.com/embed/CUXq9Mt1pr4", offer: "https://wa.link/8cqdpw", pdf: "https://www.escuelaconstrucciondigital.com/bundle/re-modelado-y-coordinacion-bim" }, 
            { t: "GESTIÓN DE CONTRATOS NEC", pos: "left-front", type: 5, img: 'img/stand5.jpg', vid: "https://www.youtube.com/embed/tUrBVim7BfE", offer: "https://wa.link/r5jseg", pdf: "https://www.escuelaconstrucciondigital.com/bundle/re-gestion-de-contratos-nec" },
            { t: "BIM MANAGER", pos: "right-back", type: 2, img: 'img/stand6.jpg', vid: "https://www.youtube.com/embed/35kRaUVD368", offer: "https://wa.link/cj77kr", pdf: "https://www.escuelaconstrucciondigital.com/bundle/re-bim-manager" }, 
            { t: "BIM CONTRACT MANAGER + NEC", pos: "right-back", type: 1, img: 'img/stand7.jpg', vid: "https://www.youtube.com/embed/ln1IR-HvsnA", offer: "https://wa.link/44lx5g", pdf: "#" }, 
            { t: "BIM MANAGER", pos: "right-back", type: 5, img: 'img/stand8.jpg', vid: "https://www.youtube.com/embed/35kRaUVD368", offer: "https://wa.link/cj77kr", pdf: "https://www.escuelaconstrucciondigital.com/bundle/re-bim-manager" }, 
            { t: "BIM EN OBRA", pos: "right-front", type: 3, img: 'img/stand9.jpg', vid: "https://www.youtube.com/embed/PPiRvRwvfWw", offer: "https://wa.link/gcyf8m", pdf: "https://www.escuelaconstrucciondigital.com/bundle/re-bim-en-obra" }, 
            { t: "BIM PROJECT MANAGER", pos: "right-front", type: 4, img: 'img/stand10.jpg', vid: "https://www.youtube.com/embed/1n8ENEgdyo0", offer: "https://wa.link/od3wb6", pdf: "#" }, 
            { t: "MEMBRESÍA FULL ACCESS", pos: "center", type: 'main', img: 'img/stand_principal.jpg', vid: "https://www.youtube.com/embed/HgoKDJcGn1k", offer: "https://wa.link/2foufd", pdf: "#" },
            { t: "SALIDA", pos: "exit-center", type: 'exit-main', img: 'img/salida_centro.jpg', link: "https://www.escuelaconstrucciondigital.com/home" }, 
            { t: "WEB", pos: "exit-left", type: 'exit-side', img: 'img/salida_izq.jpg', link: "https://bim-market.com/" }, 
            { t: "CONTACTO", pos: "exit-right", type: 'exit-side', img: 'img/salida_der.jpg', link: "https://www.skool.com/construpro" } 
        ];

        THREE.PointerLockControls=function(t,e){if(void 0===e&&(e=document.body),this.domElement=e,this.isLocked=!1,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.pointerSpeed=1.0,!(t instanceof THREE.Camera))throw new Error("THREE.PointerLockControls: First parameter must be a camera.");var n=this,o={type:"change"},r={type:"lock"},i={type:"unlock"},c=new THREE.Euler(0,0,0,"YXZ"),s=Math.PI/2,a=new THREE.Vector3;function l(e){if(!1!==n.isLocked){var r=e.movementX||e.mozMovementX||e.webkitMovementX||0,i=e.movementY||e.mozMovementY||e.webkitMovementY||0;c.setFromQuaternion(t.quaternion),c.y-=r*.002*n.pointerSpeed,c.x-=i*.002*n.pointerSpeed,c.x=Math.max(s-n.maxPolarAngle,Math.min(s-n.minPolarAngle,c.x)),t.quaternion.setFromEuler(c),n.dispatchEvent(o)}}function u(){n.domElement.ownerDocument.pointerLockElement===n.domElement?(n.dispatchEvent(r),n.isLocked=!0):(n.dispatchEvent(i),n.isLocked=!1)}this.connect=function(){n.domElement.ownerDocument.addEventListener("mousemove",l,!1),n.domElement.ownerDocument.addEventListener("pointerlockchange",u,!1)},this.disconnect=function(){n.domElement.ownerDocument.removeEventListener("mousemove",l,!1),n.domElement.ownerDocument.removeEventListener("pointerlockchange",u,!1)},this.dispose=function(){this.disconnect()},this.getObject=function(){return t},this.getDirection=function(){var e=new THREE.Vector3(0,0,-1);return function(n){return n.copy(e).applyQuaternion(t.quaternion)}}(),this.moveForward=function(e){a.setFromMatrixColumn(t.matrix,0),a.crossVectors(t.up,a),t.position.addScaledVector(a,e)},this.moveRight=function(e){a.setFromMatrixColumn(t.matrix,0),t.position.addScaledVector(a,e)},this.lock=function(){this.domElement.requestPointerLock()},this.unlock=function(){n.domElement.ownerDocument.exitPointerLock()},this.connect()};THREE.PointerLockControls.prototype=Object.create(THREE.EventDispatcher.prototype),THREE.PointerLockControls.prototype.constructor=THREE.PointerLockControls;

        let camera, scene, renderer, controls, raycaster;
        let moveF=false, moveB=false, moveL=false, moveR=false;
        let prevTime = performance.now();
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        const CENTER_SCREEN = new THREE.Vector2(0, 0);
        const interactables = []; 
        const screensToAnimate = []; 
        const vipDisplaysToAnimate = []; 
        let hovered = null; 
        const textureLoader = new THREE.TextureLoader();
        let lb=0, lf=0, rb=0, rf=0; 
        let isMobile = false;

        // Variables para Joysticks
        let joyL = { active: false, origin: {x:0,y:0}, current: {x:0,y:0} };
        let joyR = { active: false, origin: {x:0,y:0}, current: {x:0,y:0} };
        const JOY_MAX_RADIUS = 40;

        function createGoldCardTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 1024; canvas.height = 640; 
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 0, 1024, 640);
            gradient.addColorStop(0.0, '#f0d070'); gradient.addColorStop(0.3, '#e6c256'); 
            gradient.addColorStop(0.5, '#fff4d0'); gradient.addColorStop(0.7, '#cfaa3d'); 
            gradient.addColorStop(1.0, '#9e7e1e'); 
            ctx.fillStyle = gradient; ctx.fillRect(0,0,1024,640);
            ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
            for(let i=0; i<1024; i+=8) { for(let j=0; j<640; j+=8) { if ((i+j)%16 === 0) { ctx.beginPath(); ctx.arc(i, j, 1.5, 0, Math.PI*2); ctx.fill(); }}}
            ctx.fillStyle = '#000000'; ctx.textAlign = 'right'; ctx.font = 'bold 24px Arial'; ctx.fillText('Escuela de', 890, 80); ctx.font = 'bold 32px Arial'; ctx.fillText('CONSTRUCCIÓN', 890, 115); ctx.fillText('DIGITAL', 890, 150);
            ctx.textAlign = 'left'; ctx.font = '60px Arial'; ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillText('MEMBRESÍA', 62, 442); ctx.fillStyle = '#ffffff'; ctx.fillText('MEMBRESÍA', 60, 440); ctx.strokeStyle = '#000000'; ctx.lineWidth = 1; ctx.strokeText('MEMBRESÍA', 60, 440);
            ctx.font = 'bold 160px Arial'; ctx.shadowColor = '#b8860b'; ctx.shadowBlur = 20; ctx.fillStyle = '#ffffff'; ctx.fillText('ECD VIP', 50, 580); ctx.shadowBlur = 0; ctx.fillStyle = '#ffffff'; ctx.fillText('ECD VIP', 50, 580); ctx.strokeStyle = 'rgba(0,0,0,0.15)'; ctx.lineWidth = 3; ctx.strokeText('ECD VIP', 50, 580);
            const tex = new THREE.CanvasTexture(canvas); tex.colorSpace = THREE.SRGBColorSpace; tex.minFilter = THREE.LinearFilter; tex.magFilter = THREE.LinearFilter; return tex;
        }

        function createBeamTexture() {
            const canvas = document.createElement('canvas'); canvas.width = 128; canvas.height = 512;
            const ctx = canvas.getContext('2d');
            const gradient = ctx.createLinearGradient(0, 512, 0, 0);
            gradient.addColorStop(0, 'rgba(255, 170, 0, 0.0)'); gradient.addColorStop(0.3, 'rgba(255, 200, 0, 0.1)'); gradient.addColorStop(1, 'rgba(255, 255, 100, 0.4)'); 
            ctx.fillStyle = gradient; ctx.fillRect(0,0,128,512); return new THREE.CanvasTexture(canvas);
        }

        const cardTexture = createGoldCardTexture();
        const beamTexture = createBeamTexture();

        // MATERIALES SUPER OPTIMIZADOS (Fase Dark Mode)
        const matBlackMetal = new THREE.MeshLambertMaterial({ color: 0x222222 }); 
        const matDarkStone = new THREE.MeshLambertMaterial({ color: 0x111111 }); 
        const matNeonOrange = new THREE.MeshBasicMaterial({ color: 0xff4400 }); 
        const matNeonWhite = new THREE.MeshBasicMaterial({ color: 0xffffff });  
        const matNeonCyan = new THREE.MeshBasicMaterial({ color: 0x00ffff });
        const matWhiteFrame = new THREE.MeshLambertMaterial({ color: 0xeeeeee }); 

        const metalRoofMaterial = new THREE.MeshStandardMaterial({
            color: 0xe0e0e0, roughness: 0.2, metalness: 0.9, side: THREE.DoubleSide, emissive: 0x111111 
        });
        const trussMaterial = new THREE.LineBasicMaterial({
            color: 0xaaaaaa, linewidth: 1, opacity: 0.5, transparent: true
        });
        const innerStructureMat = new THREE.MeshBasicMaterial({
            color: 0x666666, wireframe: true, transparent: true, opacity: 0.15
        });
        const lampMaterial = new THREE.MeshBasicMaterial({ color: 0xffddaa });

        function freezeStatic(object) {
            object.updateMatrix();
            object.matrixAutoUpdate = false; 
            if (object.children && object.children.length > 0) {
                object.children.forEach(child => freezeStatic(child));
            }
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            const bgColor = 0x050505; 
            scene.background = new THREE.Color(bgColor); 
            scene.fog = new THREE.FogExp2(bgColor, 0.002);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.7, 30); 

            // ILUMINACIÓN OPTIMIZADA
            const ambient = new THREE.AmbientLight(0xffffff, 0.7); 
            scene.add(ambient);
            
            const mainLight = new THREE.DirectionalLight(0x88aaff, 1.0); 
            mainLight.position.set(-50, 80, -30);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 1024; 
            mainLight.shadow.mapSize.height = 1024;
            mainLight.shadow.camera.left = -100;
            mainLight.shadow.camera.right = 100;
            mainLight.shadow.camera.top = 100;
            mainLight.shadow.camera.bottom = -100;
            scene.add(mainLight);

            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.1;
            
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.shadowMap.autoUpdate = false; 
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

            document.body.appendChild(renderer.domElement);

            // DETECTAR MÓVIL
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

            controls = new THREE.PointerLockControls(camera, document.body);
            
            const blocker = document.getElementById('blocker');
            const startBtn = document.getElementById('start-btn');
            const mobileActionBtn = document.getElementById('mobile-action-btn');

            // LÓGICA DE INICIO SEGÚN DISPOSITIVO
            if (isMobile) {
                // MODO MÓVIL
                document.querySelector('.instructions').style.display = 'none'; // Ocultar texto de teclas
                document.getElementById('joystick-left').style.display = 'block';
                document.getElementById('joystick-right').style.display = 'block';
                
                startBtn.addEventListener('click', () => {
                    blocker.style.opacity = 0;
                    setTimeout(() => { blocker.style.display = 'none'; }, 500);
                });

                setupJoysticks();
                
                // Botón de acción táctil
                mobileActionBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (hovered) {
                        const d = hovered.userData.data;
                        if(d.pos.includes('exit')) { window.open(d.link || '#', '_blank'); } 
                        else { openModal(d); }
                    }
                });

            } else {
                // MODO PC
                startBtn.addEventListener('click', () => { controls.lock(); });
                controls.addEventListener('lock', () => {
                    blocker.style.opacity = 0;
                    setTimeout(() => { blocker.style.display = 'none'; }, 500);
                });
                controls.addEventListener('unlock', () => {
                    if(document.getElementById('stand-modal').style.display !== 'flex') {
                        blocker.style.display = 'flex';
                        void blocker.offsetWidth; 
                        blocker.style.opacity = 1;
                        startBtn.innerText = "REANUDAR"; 
                    }
                });
                document.addEventListener('keydown', (e) => onKey(e, true));
                document.addEventListener('keyup', (e) => onKey(e, false));
                document.addEventListener('click', onClick);
            }

            window.addEventListener('resize', onResize);
            raycaster = new THREE.Raycaster(); 

            buildEnvironment(); 
            buildLayout(); 
            renderer.shadowMap.needsUpdate = true;
        }

        // LOGICA DE JOYSTICKS TÁCTILES
        function setupJoysticks() {
            const leftZone = document.getElementById('joystick-left');
            const rightZone = document.getElementById('joystick-right');
            const leftStick = leftZone.querySelector('.stick');
            const rightStick = rightZone.querySelector('.stick');

            function handleTouch(zone, stick, joyState, e) {
                const touch = e.targetTouches[0];
                const rect = zone.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                
                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;
                const distance = Math.min(Math.hypot(dx, dy), JOY_MAX_RADIUS);
                const angle = Math.atan2(dy, dx);
                
                const moveX = Math.cos(angle) * distance;
                const moveY = Math.sin(angle) * distance;
                
                stick.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
                
                joyState.current.x = moveX / JOY_MAX_RADIUS;
                joyState.current.y = moveY / JOY_MAX_RADIUS;
                joyState.active = true;
            }

            function resetJoy(stick, joyState) {
                stick.style.transform = `translate(-50%, -50%)`;
                joyState.current.x = 0;
                joyState.current.y = 0;
                joyState.active = false;
            }

            leftZone.addEventListener('touchstart', (e) => handleTouch(leftZone, leftStick, joyL, e));
            leftZone.addEventListener('touchmove', (e) => { e.preventDefault(); handleTouch(leftZone, leftStick, joyL, e); });
            leftZone.addEventListener('touchend', () => resetJoy(leftStick, joyL));

            rightZone.addEventListener('touchstart', (e) => handleTouch(rightZone, rightStick, joyR, e));
            rightZone.addEventListener('touchmove', (e) => { e.preventDefault(); handleTouch(rightZone, rightStick, joyR, e); });
            rightZone.addEventListener('touchend', () => resetJoy(rightStick, joyR));
        }

        function onKey(e, v) {
            switch(e.code) {
                case 'KeyW': case 'ArrowUp': moveF = v; break;
                case 'KeyS': case 'ArrowDown': moveB = v; break;
                case 'KeyA': case 'ArrowLeft': moveL = v; break;
                case 'KeyD': case 'ArrowRight': moveR = v; break;
            }
        }

        function createRibbon(zPos, index, width) {
            const organicNoise = Math.sin(index * 0.6) * 3.5; 
            const randomVar = (Math.random() - 0.5) * 3.0; 
            const hGround = 0;
            const hShoulder = 8 + Math.random() * 1.5;
            const hPeakBase = 20;
            const hActualPeak = hPeakBase + organicNoise + randomVar;
            const hLowSide = hActualPeak * 0.55; 
            const isLeftLeaning = index % 2 === 0;
            const peakShift = 14; 

            let xPeak, xSlopeMid;
            if (isLeftLeaning) {
                xPeak = -peakShift + randomVar * 0.5;
                xSlopeMid = 8; 
            } else {
                xPeak = peakShift + randomVar * 0.5;
                xSlopeMid = -8;
            }

            const points = [];
            points.push(new THREE.Vector3(-35, hGround, zPos)); 
            points.push(new THREE.Vector3(-28, hShoulder, zPos));
            if (isLeftLeaning) {
                points.push(new THREE.Vector3(xPeak, hActualPeak, zPos));
                points.push(new THREE.Vector3(xSlopeMid, hActualPeak * 0.8, zPos)); 
                points.push(new THREE.Vector3(16, hLowSide, zPos));
            } else {
                points.push(new THREE.Vector3(-16, hLowSide, zPos));
                points.push(new THREE.Vector3(xSlopeMid, hActualPeak * 0.8, zPos));
                points.push(new THREE.Vector3(xPeak, hActualPeak, zPos));
            }
            points.push(new THREE.Vector3(28, hShoulder, zPos));
            points.push(new THREE.Vector3(35, hGround, zPos));

            const arcPath = new THREE.CatmullRomCurve3(points);
            arcPath.tension = 0.45; 
            
            const shapeWidth = width - 0.3;
            const shapeThickness = 0.9;     
            const shape = new THREE.Shape();
            shape.moveTo(-shapeWidth/2, -shapeThickness/2);
            shape.lineTo( shapeWidth/2, -shapeThickness/2);
            shape.lineTo( shapeWidth/2,  shapeThickness/2);
            shape.lineTo(-shapeWidth/2,  shapeThickness/2);
            shape.lineTo(-shapeWidth/2, -shapeThickness/2);

            const extrudeSettings = { steps: 70, bevelEnabled: false, extrudePath: arcPath };
            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            const lightPoint1 = arcPath.getPoint(0.35);
            const lightPoint2 = arcPath.getPoint(0.65);

            return { geometry, curve: arcPath, lightPoints: [lightPoint1, lightPoint2] };
        }

        function createFacade(zPos, curve3D) {
            const facadeGroup = new THREE.Group();
            const divisions = 100; 
            const points3D = curve3D.getPoints(divisions);
            
            const shapePoints = points3D.map(p => new THREE.Vector2(p.x, p.y));
            if (shapePoints[0].y > 0.1) shapePoints.unshift(new THREE.Vector2(shapePoints[0].x, 0));
            if (shapePoints[shapePoints.length-1].y > 0.1) shapePoints.push(new THREE.Vector2(shapePoints[shapePoints.length-1].x, 0));
            const shape = new THREE.Shape(shapePoints);
            
            const glassGeo = new THREE.ShapeGeometry(shape);
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff, metalness: 0.1, roughness: 0.05, transmission: 0.9,
                transparent: true, thickness: 0.5, side: THREE.DoubleSide, reflectivity: 0.9, ior: 1.5
            });
            const glassMesh = new THREE.Mesh(glassGeo, glassMat);
            glassMesh.position.z = zPos;
            facadeGroup.add(glassMesh);
            
            const frameMaterial = new THREE.MeshStandardMaterial({ color: 0xcccccc, roughness: 0.4, metalness: 0.7 });
            const borderPath = new THREE.CatmullRomCurve3(points3D.map(p => new THREE.Vector3(p.x, p.y, zPos)));
            const borderGeo = new THREE.TubeGeometry(borderPath, 100, 0.3, 4, false);
            const borderMesh = new THREE.Mesh(borderGeo, frameMaterial);
            facadeGroup.add(borderMesh);
            return facadeGroup;
        }

        function buildEnvironment() {
            const planeGeometry = new THREE.PlaneGeometry(350, 350);
            const planeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xadb3af, roughness: 0.9, metalness: 0.1
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane);

            const gridHelper = new THREE.GridHelper(350, 70, 0x333344, 0x222233);
            gridHelper.position.y = 0.01;
            scene.add(gridHelper);

            const group = new THREE.Group();
            const numRibbons = 14; 
            const galleryLength = 140; 
            const ribbonWidth = galleryLength / numRibbons;
            let firstCurve = null, lastCurve = null;

            for (let i = 0; i < numRibbons; i++) {
                const zPos = (i * ribbonWidth) - (galleryLength / 2) + (ribbonWidth / 2);
                
                const result = createRibbon(zPos, i, ribbonWidth);
                const geometry = result.geometry;
                const lightPoints = result.lightPoints;
                
                if (i === 0) firstCurve = result.curve;
                if (i === numRibbons - 1) lastCurve = result.curve;
                
                const mesh = new THREE.Mesh(geometry, metalRoofMaterial);
                mesh.castShadow = true; mesh.receiveShadow = true;
                group.add(mesh);

                const wireframeGeom = new THREE.WireframeGeometry(geometry);
                const structure = new THREE.LineSegments(wireframeGeom, trussMaterial);
                structure.scale.set(0.995, 0.995, 0.995);
                group.add(structure);

                const innerVol = new THREE.Mesh(geometry, innerStructureMat);
                innerVol.scale.set(0.95, 0.95, 0.95);
                group.add(innerVol);

                lightPoints.forEach(point => {
                    const lampGeo = new THREE.SphereGeometry(0.3, 8, 8); // Polígonos reducidos
                    const lampMesh = new THREE.Mesh(lampGeo, lampMaterial);
                    lampMesh.position.set(point.x, point.y - 2.0, point.z);
                    group.add(lampMesh);
                });
            }
            if (firstCurve) group.add(createFacade(-(galleryLength / 2), firstCurve));
            if (lastCurve) group.add(createFacade((galleryLength / 2), lastCurve));
            
            freezeStatic(group);
            scene.add(group);
        }

        function createScreen(w, h, data) {
            const finalW = 3.5; const finalH = 5.0;
            let tex = data.img ? textureLoader.load(data.img) : null;
            const mat = tex ? new THREE.MeshBasicMaterial({ map: tex }) : new THREE.MeshBasicMaterial({ color: 0x444 });
            const mesh = new THREE.Mesh(new THREE.PlaneGeometry(finalW, finalH), mat);
            mesh.userData = { data: data };
            interactables.push(mesh);
            screensToAnimate.push(mesh);
            return mesh;
        }
        
        function addLocalLight(group, color, intensity, distance, x, y, z) {}

        function buildStandType1(group, data) {
            for(let i=0; i<3; i++) {
                const r = 3.5 - (i*0.5); const h = 0.2;
                const base = new THREE.Mesh(new THREE.CylinderGeometry(r, r, h, 16), matBlackMetal);
                base.position.y = i*h; base.receiveShadow = true; group.add(base);
                const ring = new THREE.Mesh(new THREE.TorusGeometry(r, 0.02, 8, 24), matNeonOrange);
                ring.rotation.x = Math.PI/2; ring.position.y = i*h + h/2; group.add(ring);
            }
            const archGeo = new THREE.TorusGeometry(3.2, 0.4, 6, 12, Math.PI * 1.2); 
            const arch = new THREE.Mesh(archGeo, matDarkStone);
            arch.rotation.z = 0.6; arch.position.y = 3.5; arch.castShadow = true; group.add(arch);
            const archLight = new THREE.Mesh(new THREE.TorusGeometry(3.2, 0.05, 6, 24, Math.PI * 1.2), matNeonWhite);
            archLight.rotation.z = 0.6; archLight.position.y = 3.5; group.add(archLight);
            const screen = createScreen(null, null, data);
            screen.position.set(0, 3.8, 0); group.add(screen);
        }

        function buildStandType2(group, data) {
            const base = new THREE.Mesh(new THREE.CylinderGeometry(3.5, 3.5, 0.3, 16), matBlackMetal);
            base.position.y = 0.15; base.receiveShadow = true; group.add(base);
            const baseRing = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.05, 8, 24), matNeonOrange);
            baseRing.rotation.x = Math.PI/2; baseRing.position.y = 0.3; group.add(baseRing);
            const bigRhombus = new THREE.Mesh(new THREE.TorusGeometry(4.5, 0.2, 4, 4), matWhiteFrame); 
            bigRhombus.rotation.z = 0; bigRhombus.position.set(0, 4.5, -0.5); bigRhombus.castShadow = true; group.add(bigRhombus);
            const bigLight = new THREE.Mesh(new THREE.TorusGeometry(4.5, 0.05, 4, 4), matNeonWhite);
            bigLight.rotation.z = 0; bigLight.position.set(0, 4.5, -0.4); group.add(bigLight);
            const midRhombus = new THREE.Mesh(new THREE.TorusGeometry(3.8, 0.2, 4, 4), matWhiteFrame);
            midRhombus.rotation.z = 0; midRhombus.position.set(0, 4.5, 0); midRhombus.castShadow = true; group.add(midRhombus);
            const midLight = new THREE.Mesh(new THREE.TorusGeometry(3.8, 0.05, 4, 4), matNeonWhite);
            midLight.rotation.z = 0; midLight.position.set(0, 4.5, 0.1); group.add(midLight);
            const screen = createScreen(null, null, data);
            screen.position.set(0, 4.2, 0.5); group.add(screen);
        }

        function buildStandType3(group, data) {
            const base = new THREE.Mesh(new THREE.CylinderGeometry(4, 4.2, 0.3, 16), matDarkStone);
            base.position.y = 0.15; base.receiveShadow = true; group.add(base);
            const ring = new THREE.Mesh(new THREE.TorusGeometry(4, 0.05, 8, 24), matNeonOrange);
            ring.rotation.x = Math.PI/2; ring.position.y = 0.3; group.add(ring);
            for(let i=0; i<7; i++) {
                const angle = (Math.PI/8) * (i - 3); 
                const block = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.3, 0.5), matBlackMetal);
                block.position.set(Math.sin(angle)*3.5, 5.5 + Math.cos(angle)*1.8, 0);
                block.lookAt(0, 3, 0); block.castShadow = true; group.add(block);
                const lightStrip = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.05, 0.52), matNeonWhite);
                lightStrip.position.copy(block.position); lightStrip.lookAt(0, 3, 0); group.add(lightStrip);
            }
            const screen = createScreen(null, null, data);
            screen.position.set(0, 3.5, 0); group.add(screen);
        }

        function buildStandType4(group, data) {
            const baseH = 0.2;
            const base = new THREE.Mesh(new THREE.CylinderGeometry(4, 4, baseH, 16), matBlackMetal);
            base.position.y = baseH/2; base.receiveShadow = true; group.add(base);
            const baseRing = new THREE.Mesh(new THREE.TorusGeometry(4, 0.05, 8, 24), matNeonOrange);
            baseRing.rotation.x = Math.PI/2; baseRing.position.y = baseH + 0.05; group.add(baseRing);
            const topH = 7.5; 
            const proj = new THREE.Mesh(new THREE.CylinderGeometry(1.5, 1.5, 0.3, 16), matBlackMetal);
            proj.position.y = topH; group.add(proj);
            const projRing = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.05, 8, 24), matNeonWhite);
            projRing.rotation.x = Math.PI/2; projRing.position.y = topH - 0.15; group.add(projRing);
            const screen = createScreen(null, null, data);
            screen.position.set(0, (topH/2) + 0.5, 0); 
            screen.material.transparent = false; screen.material.opacity = 1.0;
            group.add(screen);
        }

        function buildStandType5(group, data) {
            const base = new THREE.Mesh(new THREE.CylinderGeometry(3, 3.5, 0.5, 16), matBlackMetal);
            base.position.y = 0.25; base.receiveShadow = true; group.add(base);
            const lightRing = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.05, 8, 24), matNeonOrange);
            lightRing.rotation.x = Math.PI/2; lightRing.position.y = 0.25; group.add(lightRing);
            for(let i=0; i<3; i++) {
                const size = 4.5 - (i*0.8); 
                const shapeGeo = new THREE.TorusGeometry(size, 0.1, 4, 4); 
                const shape = new THREE.Mesh(shapeGeo, matNeonWhite);
                shape.rotation.z = Math.PI/4; shape.position.set(0, 4.0, -i * 0.5);
                shape.castShadow = true; group.add(shape);
            }
            const screen = createScreen(null, null, data);
            screen.position.set(0, 4.0, 0); group.add(screen);
        }

        function buildVIPDisplay(group, position) {
            const vipGroup = new THREE.Group();
            vipGroup.position.copy(position);
            group.add(vipGroup);

            const baseGeo = new THREE.CylinderGeometry(2.2, 2.5, 0.6, 32);
            const base = new THREE.Mesh(baseGeo, matBlackMetal);
            base.position.y = 0.3; vipGroup.add(base);
            const neonGeo = new THREE.TorusGeometry(2.2, 0.05, 8, 64);
            const neonMat = new THREE.MeshBasicMaterial({ color: 0xffd700 }); 
            const neon = new THREE.Mesh(neonGeo, neonMat);
            neon.rotation.x = Math.PI / 2; neon.position.y = 0.62; vipGroup.add(neon);

            const cardWrapper = new THREE.Group();
            cardWrapper.position.y = 2.5; 
            cardWrapper.rotation.x = Math.PI * 0.1;  
            cardWrapper.rotation.z = Math.PI * 0.15; 
            cardWrapper.rotation.y = -Math.PI * 0.1; 
            vipGroup.add(cardWrapper);

            const cardGroup = new THREE.Group(); cardWrapper.add(cardGroup);
            const cardGeo = new THREE.PlaneGeometry(3.8 * 0.7, 2.4 * 0.7);

            const mainCardMat = new THREE.MeshStandardMaterial({
                map: cardTexture, roughness: 0.3, metalness: 0.6, side: THREE.DoubleSide, emissive: 0x332200, emissiveIntensity: 0.2
            });
            const mainCard = new THREE.Mesh(cardGeo, mainCardMat); cardGroup.add(mainCard);

            const layerMat = new THREE.MeshBasicMaterial({
                map: cardTexture, transparent: true, opacity: 0.15, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false, color: 0xffcc00 
            });
            for(let i=1; i<=4; i++) {
                const layer = new THREE.Mesh(cardGeo, layerMat);
                layer.position.z = -i * 0.12 * 0.7; layer.scale.multiplyScalar(1.0 + i * 0.04); cardGroup.add(layer);
            }
            const scanBar = new THREE.Mesh(new THREE.PlaneGeometry(4.2 * 0.7, 0.08 * 0.7), new THREE.MeshBasicMaterial({
                color: 0xffffff, transparent: true, opacity: 0.8, blending: THREE.AdditiveBlending, side: THREE.DoubleSide
            })); cardGroup.add(scanBar);

            const beamMesh = new THREE.Mesh(new THREE.ConeGeometry(2.5 * 0.7, 4.0 * 0.7, 32, 1, true), new THREE.MeshBasicMaterial({
                map: beamTexture, transparent: true, opacity: 0.25, color: 0xffaa00, blending: THREE.AdditiveBlending, side: THREE.DoubleSide, depthWrite: false
            }));
            beamMesh.position.y = -0.5 * 0.7; beamMesh.rotation.x = Math.PI; cardWrapper.add(beamMesh);

            const particlesGeo = new THREE.BufferGeometry();
            const pCount = 100; // Partículas reducidas
            const pPos = new Float32Array(pCount * 3);
            for(let i=0; i<pCount*3; i++) pPos[i] = (Math.random()-0.5)*5; 
            particlesGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            const particlesMat = new THREE.PointsMaterial({ color: 0xffcc00, size: 0.03, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending });
            const particleSystem = new THREE.Points(particlesGeo, particlesMat); particleSystem.position.y = 2.5; vipGroup.add(particleSystem);

            vipGroup.userData.update = function(time) {
                vipGroup.rotation.y = time * 0.5;
                cardGroup.position.z = Math.sin(time * 1.5) * 0.05; 
                const scanY = (time * 1.5) % 3.0 - 1.5; scanBar.position.y = scanY * 0.7; scanBar.visible = Math.abs(scanY) < 1.3;
                beamMesh.material.opacity = 0.2 + Math.sin(time * 8) * 0.05;
            };
            vipDisplaysToAnimate.push(vipGroup);
        }

        function buildMainStand(group, data) { 
            const base = new THREE.Mesh(new THREE.CylinderGeometry(5, 5, 0.2, 32), matBlackMetal);
            base.position.y = 0.1; base.receiveShadow = true; group.add(base);
            const baseLight = new THREE.Mesh(new THREE.TorusGeometry(5, 0.05, 16, 32), matNeonOrange);
            baseLight.rotation.x = Math.PI/2; baseLight.position.y = 0.2; group.add(baseLight);

            let tex = data.img ? textureLoader.load(data.img) : null;
            const mat = tex ? new THREE.MeshBasicMaterial({ map: tex }) : new THREE.MeshBasicMaterial({ color: 0x555 });
            const screen = new THREE.Mesh(new THREE.PlaneGeometry(12, 8), mat); 
            screen.position.set(0, 6, 0); 
            screen.userData = { data: data };
            interactables.push(screen);
            screensToAnimate.push(screen); 
            group.add(screen);

            buildVIPDisplay(group, new THREE.Vector3(-8, 0, 3));
            buildVIPDisplay(group, new THREE.Vector3(8, 0, 3));
        }
        
        function createSalidaSignTexture() {
            const cvs = document.createElement('canvas'); cvs.width=512; cvs.height=128;
            const ctx = cvs.getContext('2d');
            ctx.fillStyle = '#111'; ctx.fillRect(0,0,512,128);
            ctx.strokeStyle = '#00d2ff'; ctx.lineWidth = 8; ctx.strokeRect(4,4,504,120);
            ctx.fillStyle = '#00d2ff'; ctx.font = 'bold 80px "Teko", sans-serif'; 
            ctx.textAlign = 'center'; ctx.textBaseline='middle';
            ctx.fillText("SALIDA", 256, 64);
            return new THREE.CanvasTexture(cvs);
        }

        function buildDetailedMainExit(group, data) { 
            const matDarkMetal = new THREE.MeshLambertMaterial({ color: 0x222222 }); // Standard -> Lambert
            const matFloor = new THREE.MeshLambertMaterial({ color: 0x222222 }); // Standard -> Lambert
            const stepGeo = new THREE.BoxGeometry(12, 0.4, 3);
            const step = new THREE.Mesh(stepGeo, matFloor);
            step.position.set(0, 0.2, 1.5); group.add(step);
            const edge = new THREE.Mesh(new THREE.BoxGeometry(12, 0.05, 0.05), matNeonOrange); 
            edge.position.set(0, 0.4, 3); group.add(edge);
            const frameHeight = 7; const frameZ = 3.5;
            const pilarGeo = new THREE.BoxGeometry(0.8, frameHeight, 0.8);
            const pilarL = new THREE.Mesh(pilarGeo, matDarkMetal); pilarL.position.set(-5, frameHeight/2 + 0.4, frameZ); group.add(pilarL);
            const pilarR = new THREE.Mesh(pilarGeo, matDarkMetal); pilarR.position.set(5, frameHeight/2 + 0.4, frameZ); group.add(pilarR);
            const topBar = new THREE.Mesh(new THREE.BoxGeometry(10.8, 0.8, 0.8), matDarkMetal); 
            topBar.position.set(0, frameHeight + 0.4, frameZ); group.add(topBar);
            const neonL = new THREE.Mesh(new THREE.BoxGeometry(0.1, frameHeight, 0.1), matNeonWhite); neonL.position.set(-4.6, frameHeight/2 + 0.4, frameZ + 0.4); group.add(neonL); 
            const neonR = new THREE.Mesh(new THREE.BoxGeometry(0.1, frameHeight, 0.1), matNeonWhite); neonR.position.set(4.6, frameHeight/2 + 0.4, frameZ + 0.4); group.add(neonR); 
            const neonT = new THREE.Mesh(new THREE.BoxGeometry(10, 0.1, 0.1), matNeonWhite); neonT.position.set(0, frameHeight + 0.4 - 0.4, frameZ + 0.4); group.add(neonT); 

            const signBox = new THREE.Mesh(new THREE.BoxGeometry(4, 1.2, 0.2), matDarkMetal); 
            signBox.position.set(0, frameHeight + 1.4, frameZ); group.add(signBox);
            const signTex = createSalidaSignTexture();
            const signPlane = new THREE.Mesh(new THREE.PlaneGeometry(3.8, 1.0), new THREE.MeshBasicMaterial({map: signTex, transparent: true}));
            signPlane.position.set(0, frameHeight + 1.4, frameZ + 0.11); group.add(signPlane);

            const portalWidth = 9; const portalHeight = 6;
            const portalTex = textureLoader.load(data.img);
            const portal = new THREE.Mesh(new THREE.PlaneGeometry(portalWidth, portalHeight), new THREE.MeshBasicMaterial({ map: portalTex }));
            portal.position.set(0, frameHeight/2 + 0.9, frameZ - 0.5); 
            portal.userData = { data: data }; interactables.push(portal); group.add(portal);
        }

        function buildDetailedSideExit(group, data) { 
            const matDarkMetal = new THREE.MeshLambertMaterial({ color: 0x333333 }); // Standard -> Lambert
            const matFloor = new THREE.MeshLambertMaterial({ color: 0x222222 }); // Standard -> Lambert
            const basePlatform = new THREE.Mesh(new THREE.BoxGeometry(9, 0.3, 2.5), matFloor);
            basePlatform.position.set(0, 0.15, 0); group.add(basePlatform);
            const baseEdge = new THREE.Mesh(new THREE.BoxGeometry(9, 0.05, 0.05), matNeonOrange); 
            baseEdge.position.set(0, 0.3, 1.25); group.add(baseEdge);

            const archHeight = 6; const archWidth = 7;
            const pilarGeo = new THREE.CylinderGeometry(0.5, 0.5, archHeight, 16);
            const pilarL = new THREE.Mesh(pilarGeo, matDarkMetal); pilarL.position.set(-archWidth/2, archHeight/2 + 0.3, 0); group.add(pilarL);
            const pilarR = new THREE.Mesh(pilarGeo, matDarkMetal); pilarR.position.set(archWidth/2, archHeight/2 + 0.3, 0); group.add(pilarR);
            const archTop = new THREE.Mesh(new THREE.TorusGeometry(archWidth/2, 0.5, 8, 24, Math.PI), matDarkMetal);
            archTop.position.set(0, archHeight/2 + 0.3, 0); archTop.rotation.z = Math.PI; group.add(archTop);

            const ringGeo = new THREE.TorusGeometry(0.55, 0.05, 8, 16);
            for(let y=2; y<archHeight; y+=2) {
                const ringL = new THREE.Mesh(ringGeo, matNeonWhite); ringL.rotation.x = Math.PI/2; ringL.position.set(-archWidth/2, y + 0.3, 0); group.add(ringL); 
                const ringR = new THREE.Mesh(ringGeo, matNeonWhite); ringR.rotation.x = Math.PI/2; ringR.position.set(archWidth/2, y + 0.3, 0); group.add(ringR); 
            }
            const archNeon = new THREE.Mesh(new THREE.TorusGeometry(archWidth/2, 0.05, 8, 24, Math.PI), matNeonWhite); 
            archNeon.position.set(0, archHeight/2 + 0.3, 0.6); archNeon.rotation.z = Math.PI; group.add(archNeon); 

            const portalW = archWidth - 1; const portalH = archHeight + (archWidth/2) - 1; 
            const portalTex = textureLoader.load(data.img);
            const portal = new THREE.Mesh(new THREE.PlaneGeometry(portalW, portalH*0.8), new THREE.MeshBasicMaterial({ map: portalTex }));
            portal.position.set(0, portalH*0.4 + 0.8, -0.5); 
            portal.userData = { data: data }; interactables.push(portal); group.add(portal);
        }

        function buildLayout() {
            DATA.forEach(d => {
                const group = new THREE.Group();
                let x=0, z=0, rot=0;
                if(d.pos === 'left-back') { z = 12 - (lb++ * 14); x = -15; rot = Math.PI/4; } 
                else if (d.pos === 'left-front') { z = 6 - (lf++ * 14); x = -8; rot = Math.PI/6; } 
                else if(d.pos === 'right-back') { z = 12 - (rb++ * 14); x = 15; rot = -Math.PI/4; } 
                else if(d.pos === 'right-front') { z = 6 - (rf++ * 14); x = 8; rot = -Math.PI/6; } 
                else if(d.pos === 'center') { x = 0; z = -40; rot = 0; } 
                else if(d.pos.includes('exit')) {
                    z = 45; rot = Math.PI; 
                    if(d.pos.includes('center')) x=0;
                    if(d.pos.includes('left')) x=-12; 
                    if(d.pos.includes('right')) x=12; 
                }
                group.position.set(x, 0, z);
                group.rotation.y = rot;
                if(d.type === 1) buildStandType1(group, d);
                else if(d.type === 2) buildStandType2(group, d);
                else if(d.type === 3) buildStandType3(group, d);
                else if(d.type === 4) buildStandType4(group, d);
                else if(d.type === 5) buildStandType5(group, d);
                else if(d.type === 'main') buildMainStand(group, d);
                else if(d.type === 'exit-main') buildDetailedMainExit(group, d);
                else if(d.type === 'exit-side') buildDetailedSideExit(group, d);
                
                freezeStatic(group);
                scene.add(group);
            });
            
            screensToAnimate.forEach(screen => screen.matrixAutoUpdate = true);
            vipDisplaysToAnimate.forEach(group => {
                group.matrixAutoUpdate = true;
                group.traverse(child => child.matrixAutoUpdate = true);
            });
        }

        function onClick() {
            if(!isMobile && controls.isLocked && hovered) {
                const d = hovered.userData.data;
                if(d.pos.includes('exit')) { window.open(d.link || '#', '_blank'); } 
                else { openModal(d); controls.unlock(); }
            }
        }

        function openModal(d) {
            document.getElementById('m-title').innerText = d.t;
            const btnBuy = document.getElementById('m-buy');
            btnBuy.href = d.offer || "#";
            const btnDoc = document.getElementById('m-doc');
            btnDoc.href = d.pdf || "#";

            const content = d.vid ? IFRAME_TEMPLATE(d.vid) : '<h2 style="color:white;">VIDEO PENDIENTE</h2>';
            document.getElementById('video-wrapper').innerHTML = content;
            document.getElementById('stand-modal').style.display = 'flex';
        }

        window.closeModal = function() {
            document.getElementById('stand-modal').style.display = 'none';
            document.getElementById('video-wrapper').innerHTML = '';
            if(!isMobile) controls.lock(); 
        }

        function onResize() {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const timeSec = time / 1000;
            const delta = (time - prevTime) / 1000;

            screensToAnimate.forEach(screen => {
                screen.lookAt(camera.position.x, screen.position.y, camera.position.z);
            });

            vipDisplaysToAnimate.forEach(vipDisplay => {
                if (vipDisplay.userData.update) {
                    vipDisplay.userData.update(timeSec);
                }
            });

            raycaster.setFromCamera(CENTER_SCREEN, camera);
            const intersects = raycaster.intersectObjects(interactables);
            
            // UI INTERACCIÓN
            if (intersects.length > 0 && intersects[0].distance < 20) {
                hovered = intersects[0].object;
                if (isMobile) {
                    const btn = document.getElementById('mobile-action-btn');
                    btn.style.display = 'flex';
                    if(hovered.userData.data.pos.includes('exit')) btn.innerText = "SALIR";
                    else btn.innerText = "ABRIR";
                } else {
                    const msg = document.getElementById('interaction-msg');
                    const ch = document.getElementById('crosshair');
                    msg.style.display = 'block';
                    ch.style.transform = 'translate(-50%,-50%) scale(2)';
                    ch.style.background = '#ff4400';
                    ch.style.border = 'none';
                    if(hovered.userData.data.pos.includes('exit')) msg.innerText = "CLIC PARA SALIR";
                    else msg.innerText = "CLIC PARA ABRIR";
                }
            } else {
                hovered = null;
                if (isMobile) {
                    document.getElementById('mobile-action-btn').style.display = 'none';
                } else {
                    document.getElementById('interaction-msg').style.display = 'none';
                    const ch = document.getElementById('crosshair');
                    ch.style.transform = 'translate(-50%,-50%) scale(1)';
                    ch.style.background = 'rgba(255,255,255,0.6)'; 
                    ch.style.border = '1px solid #fff';
                }
            }

            // MOVIMIENTO MÓVIL (JOYSTICKS)
            if (isMobile) {
                if (joyL.active) {
                    const speed = 20.0 * delta; 
                    const dir = new THREE.Vector3();
                    camera.getWorldDirection(dir);
                    dir.y = 0; dir.normalize();
                    
                    const side = new THREE.Vector3();
                    side.crossVectors(camera.up, dir).normalize(); 

                    camera.position.addScaledVector(dir, -joyL.current.y * speed);
                    camera.position.addScaledVector(side, -joyL.current.x * speed);
                }

                if (joyR.active) {
                    const rotSpeed = 2.0 * delta;
                    camera.rotation.y -= joyR.current.x * rotSpeed;
                }

            } else {
                // MOVIMIENTO PC
                if (controls.isLocked) {
                    velocity.x -= velocity.x * 10.0 * delta; 
                    velocity.z -= velocity.z * 10.0 * delta;
                    direction.z = Number(moveF) - Number(moveB);
                    direction.x = Number(moveR) - Number(moveL); 
                    direction.normalize();
                    if (moveF || moveB) velocity.z -= direction.z * 80.0 * delta; 
                    if (moveL || moveR) velocity.x -= direction.x * 80.0 * delta;
                    controls.moveRight(-velocity.x * delta);
                    controls.moveForward(-velocity.z * delta);
                }
            }

            prevTime = time;
            renderer.render(scene, camera);
        }
    </script>
</body>
</html>